"""Subclass of MainFrame, which is generated by wxFormBuilder."""

import wx
import ejecutar_gestor
import utilidades
import pickle
import networkx as nx
from collections import defaultdict
from copy import deepcopy
from os import path 

NORMAL = 0
CONF_ESCALA = 1
CREAR_RAMA = 2
BUSCAR_CC = 3
CREAR_HIJO = 1
FACTOR_MARGEN_X_CURVAS = 1.2
DIST_MIN = 15 #Distancia en pixeles
MONOFASICO = 0
BIFASICO = 1
TRIFASICO = 2
TEMP_60 = 2
TEMP_75 = 3
TEMP_90 = 4

CONDUCTORES = (
    #mm2  AWG o kcmil   I@60   I@75   I@90
    (2.08, 14, 15, 20, 25),
    (3.31, 12, 20, 25, 30),
    (5.26, 10, 30, 35, 40),
    (8.37,  8, 40, 50, 55),
    (13.3,  6, 55, 65, 75),
    (21.2,  4, 70, 85, 95),
    (26.7,  3, 85, 100, 115),
    (33.6,  2, 95, 115, 130),
    (42.4,  1, 110, 130, 145),
)
CALIBRES = [x[1] for x in CONDUCTORES]
DICT_SECC_TRANS = {
}
for row in CONDUCTORES:
    DICT_SECC_TRANS[row[1]] = row[0]


# Implementing MainFrame
class gestor_planos_electricos_MainFrame( ejecutar_gestor.MainFrame ):
    def __init__( self, parent ):
        ejecutar_gestor.MainFrame.__init__( self, parent )
        self.img = None
        self.ancho = 0
        self.alto = 0
        self.escala = 1
        self.escala_x = 0
        self.escala_y = 0
        self.origen = (0, 0)
        self.centro_carga = None
        self.x = 0
        self.y = 0
        self.x_abs = 0
        self.y_abs = 0
        self.referencia = (0, 0)
        self.modo = 0
        self.cuadro_distancia = None
        self.agregar_elemento = None
        self.trayectorias = defaultdict(list)
        self.trayectorias_ver = defaultdict(lambda: True)
        self.dict_objetos_x_circuito =  defaultdict(list)
        self.dict_cc_x_circuito = defaultdict(str)
        self.dict_awg_x_circuito = defaultdict(set)
        self.dict_cargas = defaultdict(lambda: defaultdict(lambda:defaultdict(lambda: {"cantidad": 0, "carga": 0})))
        self.alimentadores = None
        self.dist = None
        self.objetos = []
        self.dict_tree = {}
        self.__data__ = None
        self.update_treectrl(None)
        self.tags = defaultdict(lambda:{"controles":[], "lamparas": []})
        self.m_dataViewListCtrl.AppendTextColumn("Atributo", width=150)
        self.m_dataViewListCtrl.AppendTextColumn(
            "Valor", width=80, mode=wx.dataview.DATAVIEW_CELL_EDITABLE
        )
        self.zoom = 1

        self.imgs = {
            1: wx.Image("img/Centro_de_carga.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            3: wx.Image("img/Contacto_sencillo.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            4: wx.Image("img/Contacto_doble.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            5: wx.Image("img/Apagador_2_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            6: wx.Image("img/Apagador_3_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            7: wx.Image("img/Apagador_4_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            8: wx.Image("img/Lampara_de_techo.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            9: wx.Image("img/Lampara_de_pared.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            10: wx.Image("img/Lampara_de_piso.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            11: wx.Image("img/Placa_accesorios1.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            12: wx.Image("img/Placa_accesorios2.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            13: wx.Image("img/Placa_accesorios3.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
           111: wx.Image("img/Placa_accesorios1.png", wx.BITMAP_TYPE_ANY).Rotate90().ConvertToBitmap(),
           112: wx.Image("img/Placa_accesorios2.png", wx.BITMAP_TYPE_ANY).Rotate90().ConvertToBitmap(),
           113: wx.Image("img/Placa_accesorios3.png", wx.BITMAP_TYPE_ANY).Rotate90().ConvertToBitmap(),
        }

    def on_file_change(self, event):
        obj = event.EventObject
        self.path = obj.GetPath()
        self.img = wx.Image(self.path, wx.BITMAP_TYPE_ANY)
        self.ancho, self.alto = self.img.GetSize()
        #self.pil_img = Image.open(self.path)
        self.m_panel2.Refresh()
        #self.m_filePicker.Enable(True)
    
    def on_paint(self, event):
        """Metodo para dibujar sobre un panel"""
        if self.img is not None:
            dc = wx.PaintDC(event.EventObject)
            self.pintar(dc, self.img, event.EventObject)
        event.Skip()

    def on_save_img(self, event):
        if self.img is not None:
            panel = self.m_panel2
            ancho, alto = panel.GetSize()
            bmp = wx.Bitmap(ancho, alto)
            dc = wx.MemoryDC ()
            dc.SelectObject(bmp)
            self.pintar(dc, self.img, panel) 
            bmp.SaveFile (path.join(path.dirname(self.path), "image.bmp"), wx.BITMAP_TYPE_BMP)
            event.Skip()
    
    def pintar(self, dc, img, panel):
        """Redibuja una imagen sobre un panel"""
        
        dc.Clear()
        dc.SetBackground(wx.Brush("WHITE"))
        ancho, alto = panel.GetSize()
        self.escala_x = ancho/self.ancho
        self.escala_y = alto/self.alto
        if 0 in (ancho, alto):
            return 
        if self.img:
            imagenEscalada = self.img.Scale(
                ancho, alto, wx.IMAGE_QUALITY_HIGH
            )
            bitmap = imagenEscalada.ConvertToBitmap()
            dc.DrawBitmap(bitmap, 0, 0, True)
            x, y = self.convert_2_pixels(
                (self.x_abs, self.y_abs)
            )
            dc.SetBrush(wx.Brush("#FF0000"))
            dc.DrawCircle(
                int(self.origen[0]*self.escala_x), 
                int(int(self.origen[1]*self.escala_y)), 5)
            if self.centro_carga is not None:
                x, y = self.convert_2_pixels(
                    (self.centro_carga[0]/self.escala,
                    self.centro_carga[1]/self.escala)
                )
                dc.SetBrush(wx.Brush("#FF00FF"))
                dc.DrawCircle(
                    int(x), int(y), 5
                )
            for obj in self.objetos:
                x, y =self.convert_2_pixels((obj.x/self.escala, obj.y/self.escala))
                if obj.tipo in ["Lampara de piso", "Lampara de techo", "Lampara de pared", "Centro de carga"]:
                    idx = utilidades.TIPOS[obj.tipo]
                    ancho, alto = self.imgs[idx].GetSize()
                    dc.DrawBitmap(self.imgs[idx], int(x - ancho*0.5), int(y - alto*0.5), True)
                    dc.DrawText(obj.tag, int(x + ancho*0.5), int(y))
                    dc.DrawText(obj.circuito, int(x + ancho*0.5), int(y-alto))
                elif obj.tipo == "Placa de accesorios":
                    if len(obj.__hijos__)!= 0:
                        idx = 10 + len(obj.__hijos__)
                    else:
                        idx = 11
                    ancho_placa, alto_placa = self.imgs[idx].GetSize()
                    try:
                        if obj.girar:
                            idx += 100
                    except:
                        pass
                    try:
                        if obj.girar:
                            dc.DrawBitmap(self.imgs[idx], int(x - alto_placa*0.5), int(y - ancho_placa*0.5), True)
                            dc.DrawText(obj.circuito, int(x - alto_placa*0.5), int(y-ancho_placa))
                        else:
                            dc.DrawBitmap(self.imgs[idx], int(x - ancho_placa*0.5), int(y - alto_placa*0.5), True)
                            dc.DrawText(obj.circuito, int(x + ancho_placa*0.5), int(y - alto_placa*0.5))
                    except:
                        dc.DrawBitmap(self.imgs[idx], int(x - ancho_placa*0.5), int(y - alto_placa*0.5), True)
                        dc.DrawText(obj.circuito, int(x + ancho_placa*0.5), int(y - alto_placa*0.5))
                    if len(obj.__hijos__) > 0:
                        step_ancho = ancho_placa/(len(obj.__hijos__)) 
                        for i, hijo in enumerate(obj.__hijos__):
                            idx = utilidades.TIPOS[hijo.tipo]
                            ancho, alto = self.imgs[idx].GetSize()
                            try:
                                if obj.girar:
                                    dc.DrawBitmap(self.imgs[idx], int(x - alto_placa*0.5), int(y - ancho_placa*0.5  + step_ancho*i), True)
                                    dc.DrawText(hijo.tag, int(x + alto_placa*0.5), int(y - ancho_placa*0.5  + step_ancho*i))
                                else:
                                    dc.DrawBitmap(self.imgs[idx], int(x - ancho_placa*0.5 + step_ancho*i), int(y - alto_placa*0.5), True)
                                    dc.DrawText(hijo.tag, int(x  + step_ancho*i), int(y + alto_placa*0.5))
                            except:
                                dc.DrawBitmap(self.imgs[idx], int(x  + ancho_placa*0.5 + step_ancho*i), int(y - alto_placa*0.5), True)
                                dc.DrawText(hijo.tag, int(x + ancho*0.5), int(y))
                if obj.__selected__:
                    dc.SetBrush(wx.Brush("#FF0000"))   
                    dc.DrawCircle(int(x), int(y), 5)
        
        
        if self.trayectorias is not None:
            for circuito, ramas in self.trayectorias.items():
                if not self.trayectorias_ver[circuito]:
                    continue
                for rama in ramas:
                    if rama.__selected__:
                        dc.SetPen(wx.Pen("#FF0000"))
                    else:
                        dc.SetPen(wx.Pen(rama.color))
                    x1, y1 = self.convert_2_pixels((rama.obj1.x/self.escala, rama.obj1.y/self.escala))
                    x2, y2 = self.convert_2_pixels((rama.obj2.x/self.escala, rama.obj2.y/self.escala))
                    xm, ym = self.convert_2_pixels((rama.punto_centro[0]/self.escala, rama.punto_centro[1]/self.escala))
                    dc.DrawLine(int(x1), int(y1), int(x2), int(y2))
                    if circuito == "flujos":
                        dc.DrawText(f"{sum(rama.dict_flujos.values()):.2f}", int(xm), int(ym))
                    else:
                        dc.DrawText(f"{rama.dist:.2f}", int(xm), int(ym))

        if self.modo == CONF_ESCALA:
            x_ref, y_ref = self.convert_2_pixels(
                (self.referencia[0], self.referencia[1])
            )
            x, y = self.convert_2_pixels(
                (self.x, self.y)
            )
            dc.DrawLine(int(x_ref), int(y_ref), int(x), int(y))
            

    def convert_2_pixels(self, punto):
        """Convierte puntos en la imagen en coordenadas para el panel"""
        x, y = punto
        x = (x + self.origen[0]) * self.escala_x
        y = (y + self.origen[1]) * self.escala_y
        return x, y

    def on_change_size(self, event):
        self.Layout()
        self.Update()
        self.m_panel2.Refresh()

    def on_sash_changed(self, event):
        self.on_change_size(None)
    
    def on_mouse_motion(self, event):
        """Captura los movimientos del raton dentro del panel de dibujo"""
        if 0 in (self.escala_x, self.escala_y):
            return 
        self.x_abs = event.x/self.escala_x
        self.y_abs = event.y/self.escala_y
        self.x = (event.x/self.escala_x - self.origen[0])*self.escala
        self.y = (event.y/self.escala_y - self.origen[1])*self.escala
        
        self.m_statusBar1.SetStatusText(
            f"X: {self.x:.2f}  Y: {self.y:.2f}"
        )
        if self.modo == CONF_ESCALA:
            self.m_panel2.Refresh()

    def on_context_menu(self, event):
        self.PopupMenu(PopMenu(self.m_panel2, self))

    def on_left_down(self, event):
        if self.modo == CONF_ESCALA:
            self.modo = NORMAL
            self.m_panel2.Refresh()
            self.dist = self.calc_dist((self.x, self.y), (self.referencia))
            if self.cuadro_distancia is None:
                self.cuadro_distancia = CuadroDistancia(self)
                self.cuadro_distancia.Show()
        elif self.modo == NORMAL:
            for i, obj in enumerate(self.objetos):
                dist = self.calc_dist((self.x, self.y), (obj.x, obj.y))
                if dist < DIST_MIN*self.escala:
                    self.update_data_ctrl(obj, self.m_dataViewListCtrl)
                    obj.__selected__ = True
                    self.__data__ = obj
                    wx.CallAfter(self.m_panel2.Refresh)
                    item = self.dict_tree.get(obj, None)
                    if item is not None:
                        wx.CallAfter(self.m_treeCtrl.EnsureVisible, item)
                        wx.CallAfter(self.SetItemBackgroundColour, item, self.dict_tree, self.m_treeCtrl)
                else:
                    obj.__selected__ = False
            
            i = 0
            for circuito, ramas in self.trayectorias.items():
                if not self.trayectorias_ver[circuito]:
                    continue
                for obj in ramas:
                    dist = self.calc_dist((self.x, self.y), (obj.punto_centro[0], obj.punto_centro[1]))
                    if dist < DIST_MIN*1.5*self.escala:
                        self.update_data_ctrl(obj, self.m_dataViewListCtrl)
                        obj.__selected__ = True
                        self.__data__ = obj
                        wx.CallAfter(self.m_panel2.Refresh)
                        item = self.dict_ramas_tree.get(self.__data__, None)
                        if item is not None:
                            wx.CallAfter(self.m_treeCtrl_ramas.EnsureVisible, item)
                            wx.CallAfter(self.SetItemBackgroundColour, item, self.dict_ramas_tree, self.m_treeCtrl_ramas)
                    else:
                        obj.__selected__ = False
                    i += 1
        elif self.modo == CREAR_RAMA:
            if not isinstance(self.__data__, utilidades.Accesorio):
                self.modo=NORMAL
                return
            aux = None
            for i, obj in enumerate(self.objetos):
                dist = self.calc_dist((self.x, self.y), (obj.x, obj.y))
                if dist < DIST_MIN*self.escala:
                    aux = obj
            if aux is None:
                return
            self.trayectorias["personalizada"].append(
                utilidades.Rama(self.__data__, aux)
            )
            self.modo = NORMAL
            wx.CallAfter(self.m_panel2.Refresh)
            wx.CallAfter(self.update_ramas_treectrl, None)

    def SetItemBackgroundColour(self, item, tree_ctrl_dict, tree_ctrl):
        for valor in tree_ctrl_dict.values():
            tree_ctrl.SetItemBackgroundColour(valor, wx.Colour("#FFFFFF"))
        wx.CallAfter(tree_ctrl.SetItemBackgroundColour,item, wx.Colour("#FF4258"))
        
    def calc_dist(self, p1, p2):
        "Calcula la distancia entre 2 puntos"
        if isinstance(p1, utilidades.Accesorio) and isinstance(p2, utilidades.Accesorio):
            return ((p2.x-p1.x)**2 + (p2.y-p1.y)**2)**0.5
        else:
            return ((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)**0.5
    
    def update_treectrl(self, event):
        self.dict_tree = {}
        self.m_treeCtrl.DeleteAllItems()
        self.root = self.m_treeCtrl.AddRoot('Accesorios')
        for i, obj in enumerate(self.objetos):
            aux = self.m_treeCtrl.AppendItem(self.root,f"{i}-{obj.tipo}", data=obj)
            self.dict_tree[obj] = aux
            for j, hijo in enumerate(obj.__hijos__):
                self.m_treeCtrl.AppendItem(aux,f"{j}-{hijo.tipo}", data=hijo)
        self.m_treeCtrl.Expand(self.root)
    
    def update_tag_treectrl(self, event):
        self.dict_tag_tree = {}
        self.m_treeCtrl_tags.DeleteAllItems()
        self.root_tags = self.m_treeCtrl_tags.AddRoot('Tags')
        for i, (tag, valores) in enumerate(sorted(self.tags.items())):
            tags_root = self.m_treeCtrl_tags.AppendItem(self.root_tags, tag, data=valores["lamparas"]+valores["controles"])
            controles_root = self.m_treeCtrl_tags.AppendItem(tags_root, "controles", data=valores["controles"])
            lamparas_root = self.m_treeCtrl_tags.AppendItem(tags_root, "lamparas", data=valores["lamparas"])
            for control in valores["controles"]:
                self.m_treeCtrl_tags.AppendItem(controles_root, f"{control.tipo}", data=[control])
            for lampara in valores["lamparas"]:
                self.m_treeCtrl_tags.AppendItem(lamparas_root, f"{lampara.tipo}", data=[lampara])
        self.m_treeCtrl_tags.Expand(self.root_tags)

    def update_ramas_treectrl(self, event):
        self.dict_ramas_tree = {}
        self.m_treeCtrl_ramas.DeleteAllItems()
        self.root_ramas = self.m_treeCtrl_ramas.AddRoot('Ramas')
        i = 0
        for circuito, ramas in sorted(self.trayectorias.items()):
            if len(ramas) == 0:
                continue
            ramas_root = self.m_treeCtrl_ramas.AppendItem(self.root_ramas, circuito, data=ramas)
            for rama in ramas:
                rama_root = self.m_treeCtrl_ramas.AppendItem(ramas_root, str(i), data=[rama])
                self.dict_ramas_tree[rama] = rama_root
                self.m_treeCtrl_ramas.AppendItem(rama_root, f"{rama.obj1.tipo}", data=[rama.obj1])
                self.m_treeCtrl_ramas.AppendItem(rama_root, f"{rama.obj2.tipo}", data=[rama.obj2])
                i += 1
        self.m_treeCtrl_ramas.Expand(self.root_ramas)

    def on_click(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        if data is None:
            return
        self.update_data_ctrl(data, self.m_dataViewListCtrl)
        for obj in self.objetos:
            obj.__selected__ = False
        data.__selected__ = True
        self.__data__ = data
        wx.CallAfter(self.m_panel2.Refresh)
    
    def on_click_tags(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        if data is None:
            return
        if len(data) == 1:
            self.update_data_ctrl(data[0], self.m_dataViewListCtrl)
            self.__data__ = data[0]
        for obj in self.objetos:
            obj.__selected__ = False
        for obj in data:
            obj.__selected__ = True
            if obj.__padre__ is not None:
                obj.__padre__.__selected__ = True
        wx.CallAfter(self.m_panel2.Refresh)

    def on_click_ramas(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        if data is None:
            return
        if len(data) == 1:
            self.update_data_ctrl(data[0], self.m_dataViewListCtrl)
            self.__data__ = data[0]
        for obj in self.objetos:
            obj.__selected__ = False
        for ramas in self.trayectorias.values():
            for rama in ramas:
                rama.__selected__ = False
        for obj in data:
            obj.__selected__ = True   
            if isinstance(obj, utilidades.Rama):
                obj.obj1.__selected__ = True        
                obj.obj2.__selected__ = True        
        wx.CallAfter(self.m_panel2.Refresh)

    def update_data_ctrl(self, data, obj):
        """Muestra en pantalla los datos de un objeto del tipo NewData.
        Los atributos que inican y terminan con 2 guiones bajos no son desplegados
        
        Parameters
        ----------
        data: NewData obj
            Objeto cuya información se desea desplegar ne pantalla
        obj: wx.DataViewCtrl
            Objeto donde se desea monstrar la información.
        """
        if data is None:
            return None
        obj.DeleteAllItems()
        encabezados = list(data.__dict__.keys())
        for encabezado in encabezados:
            if encabezado.startswith("__") and encabezado.endswith("__"):
                continue
            obj.AppendItem([encabezado,str(getattr(data,encabezado))])  

    def on_context_menu_treectrl(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        self.PopupMenu(PopMenu2(self.m_treeCtrl, self, data))

    def on_context_menu_treectrl_ramas(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        text =  tree_ctrl.GetItemText(itemID)
        self.PopupMenu(PopMenu3(self.m_treeCtrl, self, data, text=text))

    def on_save(self, event):
        data = {
           "objetos" : self.objetos,
           "origen" : self.origen,
           "escala" : self.escala,
           "escala_x": self.escala_x,
           "escala_y": self.escala_y,
           "x_abs": self.x_abs,
           "y_abs": self.y_abs,
           "path": self.path,
           "circuitos_data": self.get_tabla_data(self.m_grid1),
           "trayectorias": self.trayectorias["personalizada"],
           "cc_x_circuito": self.dict_cc_x_circuito,
        }
        dlg = wx.FileDialog(self, "Archivo de recuperacion",wildcard="*.pkl", style=wx.FD_SAVE)
        if dlg.ShowModal() == wx.ID_CANCEL:
            return
        # save the current contents in the file
        pathname = dlg.GetPath()
        dbfile = open(pathname, 'wb')     
        pickle.dump(data, dbfile)                    
        dbfile.close()
    
    def on_open(self, event):
        dlg = wx.FileDialog(self, "Archivo de recuperacion","", "","*.pkl", style=wx.FD_OPEN)
        if dlg.ShowModal() == wx.ID_CANCEL:
            return
        # save the current contents in the file
        pathname = dlg.GetPath()
        dict_file = open(pathname, 'rb')  
        dict_pkld = pickle.load(dict_file)
        dict_file.close()
        self.objetos = dict_pkld["objetos"]
        self.origen = dict_pkld["origen"]
        self.escala = dict_pkld["escala"]
        self.escala_x = dict_pkld["escala_x"]
        self.escala_y = dict_pkld["escala_y"]
        self.x_abs = dict_pkld["x_abs"]
        self.y_abs = dict_pkld["y_abs"]
        self.path = dict_pkld["path"]
        self.set_tabla_data(self.m_grid1, dict_pkld["circuitos_data"])
        self.img = wx.Image(self.path, wx.BITMAP_TYPE_ANY)
        self.ancho, self.alto = self.img.GetSize()
        self.trayectorias.clear()
        try:
            self.trayectorias["personalizada"] = dict_pkld["trayectorias"]
        except:
            pass
        try:
            self.dict_cc_x_circuito = dict_pkld["cc_x_circuito"]
        except:
            pass
        wx.CallAfter(self.recalcular, None)

    def on_calc_carga(self, event):
        carga_total = 0
        data = []
        self.on_asignar_circuito(None)
        carga_aux = defaultdict(float)
        centros_carga =  [x[1].tag for x in self.on_buscar_centros_carga(None)]
        for obj in self.objetos:
            carga_total += obj.potencia
            carga_aux[obj.circuito] += obj.potencia
        data = []
        for circuito, carga in sorted(carga_aux.items()):
            eleccion = self.dict_cc_x_circuito.get(circuito, "")
            corriente = carga/127
            if len(self.dict_awg_x_circuito[circuito]) != 0:
                awg = min(self.dict_awg_x_circuito[circuito])
            else:
                awg = ""
            data.append(
                (circuito, f"{carga:.2f}", 
                    {"eleccion": eleccion if eleccion is not None else "", 
                     "data": centros_carga},
                    f"{corriente:.2f}",
                    self.dimensionar_cable(corriente, TEMP_60),
                    awg
                )
            )
        self.set_tabla_data(self.m_grid2, sorted(data))
        self.m_textCtrl_carga.SetValue(f"{carga_total:.2f}")
        return carga_total
    
    def dimensionar_cable(self, corriente, temp_idx):
        for row in CONDUCTORES:
            if row[temp_idx] >= corriente:
                return row[1]
        return ""

    def on_calc_centro_carga(self, event):
        
        carga = self.on_calc_carga(None)
        carga_x_ponderada = 0
        carga_y_ponderada = 0
        for obj in self.objetos:
            carga_x_ponderada += obj.x*obj.potencia
            carga_y_ponderada += obj.y*obj.potencia
        self.centro_carga = (
            carga_x_ponderada/carga, carga_y_ponderada/carga
        )
        wx.CallAfter(self.m_panel2.Refresh)

    def on_calc_distancias(self, event):
        self.on_generar_arbol_actual(None)
        self.m_textCtrl_distancia.SetValue(f"{self.network.size(weight="weight"):.2f}")

    def calcular_dist_obj(self, obj1, obj2):
        """Calcula la distancia entre dos objetos"""
        if obj1.tipo == "Placa de accesorios" and obj1.tipo==obj2.tipo:
            delta_z = abs(obj1.z + obj2.z)
        else:
            delta_z = abs(obj1.z - obj2.z)
        dist = self.calc_dist((obj1.x, obj1.y), (obj2.x, obj2.y))
        return (delta_z + dist) * FACTOR_MARGEN_X_CURVAS
    
    def on_ver_red(self, event):

        flg_1 = self.m_checkBox1.GetValue()
        dist_max_ll  = float(self.m_textCtrl10.GetValue())
        dist_max_al  = float(self.m_textCtrl11.GetValue())
        dist_max_cc  = float(self.m_textCtrl12.GetValue())
        dist_max_ll2  = float(self.m_textCtrl13.GetValue())
        self.trayectorias["red_propuesta"].clear()
        for i, obj1 in enumerate(self.objetos):
            for obj2 in self.objetos[:i]:
                if flg_1:
                    if obj1.tipo == "Placa de accesorios" and obj1.tipo==obj2.tipo:
                        continue
                    if  "Placa de accesorios" in [obj1.tipo,obj2.tipo] and  "Lampara de pared" in [obj1.tipo,obj2.tipo]:
                        continue
                    if  "Placa de accesorios" in [obj1.tipo,obj2.tipo] and  "Centro de carga" in [obj1.tipo,obj2.tipo]:
                        continue
                dist = self.calcular_dist_obj(obj1, obj2)
                dist_max = dist_max_al
                if (obj1.tipo in ["Lampara de techo", "Lampara de piso", "Lampara de pared"] 
                        and obj2.tipo in ["Lampara de techo", "Lampara de piso", "Lampara de pared"]):
                    if obj1.tag == obj2.tag:
                        dist_max = dist_max_ll 
                    else:
                        dist_max = dist_max_ll2
                elif "Centro de carga" in [obj1.tipo, obj2.tipo]:
                        dist_max = dist_max_cc
                if dist > dist_max:
                    continue
                self.trayectorias["red_propuesta"].append(utilidades.Rama(obj1, obj2))
        wx.CallAfter(self.update_ramas_treectrl, None)
        wx.CallAfter(self.m_panel2.Refresh)
    
    def on_verificar_controles(self, event):
        self.on_buscar_tags(None)
        self.on_generar_arbol_actual(None)
        self.trayectorias["fails"].clear()    
        #calculo de regresos entre foco y control
        flg = self.m_radioBox1.GetSelection() 
        for tag, data in self.tags.items():
            rutas = []
            for i, control in enumerate(data["controles"]):
                H = self.create_node_network(None)
                for lampara in data["lamparas"]:
                    try:
                        ruta = nx.shortest_path(self.network, source=control.__padre__, target=lampara, weight="weight")
                    except:
                        self.trayectorias["fails"].append(utilidades.Rama(control.__padre__, lampara)) 
                        continue     
                    for j, nodo in enumerate(ruta[:-1]):
                        rama = utilidades.Rama(nodo, ruta[j+1])
                        H.add_edge(nodo, ruta[j+1], weigth=rama.dist)
                aux = []
                for obj1, obj2 in H.edges():
                    aux.append(utilidades.Rama(obj1, obj2))
                rutas.append(( H.size("weigth"), f"control:{tag}-{i}", aux))
                self.trayectorias[f"control:{tag}-{i}"].clear()
            try:
                if len(data["controles"]) == 1:
                    _, key, ramas = min(rutas)
                else:
                    if flg == 0:
                        _, key, ramas = min(rutas)
                    else:
                        flg2 = True
                        for ruta in sorted(rutas):
                            if not self.todos_nodos_mismo_circuito(ruta[-1]):
                                flg2 = False
                                _, key, ramas = ruta
                                break
                        if flg2:
                            _, key, ramas = min(rutas)
                self.trayectorias[key] += ramas

                            
            except:
                pass
            #calculo de regresos entre controles
            if len(data["controles"]) > 1:
                H = self.create_node_network(None)
                for j,  control1 in enumerate(data["controles"]):
                    for k, control2 in enumerate(data["controles"][:-j]):
                        try:
                            ruta = nx.shortest_path(self.network, source=control1.__padre__, target=control2.__padre__, weight="weight")
                        except:
                            self.trayectorias["fails"].append(utilidades.Rama(control.__padre__, lampara)) 
                            continue  
                        for l, nodo in enumerate(ruta[:-1]):
                            rama = utilidades.Rama(nodo, ruta[l+1])
                            H.add_edge(nodo, ruta[l+1], weigth=rama.dist)           
                self.trayectorias[f"regresos:{tag}"].clear()
                for obj1, obj2 in H.edges():
                    rama = utilidades.Rama(obj1, obj2)
                    self.trayectorias[f"regresos:{tag}"].append(rama)

        wx.CallAfter(self.recalcular, None)

    def todos_nodos_mismo_circuito(self, ruta):
        circuitos = set()
        for rama in ruta:
            circuitos.add(rama.obj1.circuito)
            circuitos.add(rama.obj2.circuito)
        if "" in circuitos:
            return None
        return len(circuitos) == 1
            


    def create_node_network(self, event):
        H = nx.Graph()
        for obj in self.objetos:
            H.add_node(obj)
        return H  
       
    def encontrar_foco_mas_cercano(self, placa):
        aux = []
        for i, obj in enumerate(self.objetos):
            if obj.tipo not in ["Lampara de techo", "Lampara de piso", "Lampara de pared"]:
                continue
            dist = self.calcular_dist_obj(placa, obj)
            aux.append((dist, i))
        return (min(aux))

    def on_edit_data( self, event):
        """Permite la edición de un accesorio.
        """
        data_view_column = event.GetDataViewColumn()
        data_view_list_ctrl = data_view_column.GetOwner()
        item = event.GetItem()
        row = data_view_list_ctrl.ItemToRow(item)
        column = event.Column
        new_value = event.Value
        field = data_view_list_ctrl.GetValue(row,0)
        if column == 0:
            return None
        tipo = type(getattr(self.__data__, field))
        setattr(self.__data__,field,tipo(new_value))
        try:
            self.__data__.__padre__.calc_pot()
        except:
            pass
        wx.CallAfter(self.m_panel2.Refresh)
        wx.CallAfter(self.update_treectrl, None)
        self.m_statusBar1.SetStatusText("Articulo modificado exitosamente")
        event.Skip()
    
    def on_buscar_tags(self, event):
        self.tags.clear()
        for obj in self.objetos:
            for hijo in obj.__hijos__:
                if hijo.tag == "":
                    continue
                self.tags[hijo.tag]["controles"].append(hijo) 
            if obj.tag == "":
                continue
            self.tags[obj.tag]["lamparas"].append(obj)
        self.update_tag_treectrl(None)
    
    def on_buscar_espacios(self, event):
        espacios = {obj.espacio for obj in self.objetos}
        dat = {esp: (cir, cc) for esp, cir, cc in self.get_tabla_data(self.m_grid1)}
        data = [[espacio, dat.get(espacio, ["", ""])[0], dat.get(espacio, ["", ""])[1]] for espacio in espacios]
        self.set_tabla_data(self.m_grid1, sorted(data))

    def clean_table_data(self, grid):
        """Borra la informacion de una tabla"""
        num_rows = grid.GetNumberRows()
        if num_rows != 0:
            grid.DeleteRows(numRows=num_rows)
    
    def clean_table_cols(self, grid):
        """Borra las columnas de una tabla"""
        num_cols = grid.GetNumberCols()
        if num_cols != 0:
            grid.DeleteCols(numCols=num_cols)

    def set_tabla_data(self, grid, data):
        """Borra la informacion de una tabla y la rellena con los valores en data"""
        self.clean_table_data(grid)
        grid.InsertRows(numRows=len(data))
        for i, row in enumerate(data):
            for j, cell_value in enumerate(row):
                if isinstance(cell_value, dict):
                    choice_editor = wx.grid.GridCellChoiceEditor(cell_value["data"], True)
                    grid.SetCellValue(i,j,str(cell_value["eleccion"]))
                    grid.SetCellEditor(i, j, choice_editor)
                else:
                    grid.SetCellValue(i,j,str(cell_value))
        grid.Refresh()
    
    def get_tabla_data(self, grid):
        """Obtiene la información de la tabla y la entrega como una lista de listas"""
        num_rows = grid.GetNumberRows()
        num_cols = grid.GetNumberCols()
        data = []
        for row in range(num_rows):
            aux = []
            for col in range(num_cols):
                aux.append(grid.GetCellValue(row, col))
            data.append(aux)
        return data
    
    def on_asignar_circuito(self, event):
        dict_circuitos = {data[0]: data[1] for data in self.get_tabla_data(self.m_grid1)}
        for obj in self.objetos:
            if obj.espacio == "":
                continue
            try:
                obj.set_circuito(dict_circuitos[obj.espacio])
            except:
                pass
        
    def on_calcular_alimentadores(self, event):
        """Secciona los objetos por circuitos y despues calcula la distancia minima de
        uno de los accesorios del circuito al centro de carga"""
        self.on_asignar_circuito(None)
        centros_carga = self.on_buscar_centros_carga(None)
        dist_max = float(self.m_textCtrl12.GetValue())
        aux = defaultdict(list)
        for obj in self.objetos:
            for idx, centro_carga in centros_carga: 
                if obj.tipo == "Placa de accesorios":
                    continue    
                aux[obj.circuito].append(utilidades.Rama(centro_carga, obj))
        self.trayectorias["alimentadores"].clear()
        for clave in aux.values():
            alimentador = min(clave, key= lambda x:x.dist)
            if alimentador.dist > dist_max:
                continue 
            self.trayectorias["alimentadores"].append(alimentador)
        wx.CallAfter(self.recalcular, None)


    def on_buscar_centros_carga(self, event):
        centros_carga = []
        for i, obj in enumerate(self.objetos):
            if obj.espacio == "":
                continue
            if obj.tipo != "Centro de carga":
                continue
            centros_carga.append((i, obj))
        return centros_carga

    def recalcular(self, event, flg=True):
        wx.CallAfter(self.on_buscar_tags, None)
        wx.CallAfter(self.on_buscar_espacios, None)
        if flg:
            wx.CallAfter(self.on_calc_carga, None)
        wx.CallAfter(self.update_treectrl, None)
        wx.CallAfter(self.update_tag_treectrl, None)
        wx.CallAfter(self.update_ramas_treectrl, None)
        wx.CallAfter(self.on_calc_distancias, None)
        wx.CallAfter(self.m_panel2.Refresh)

    
    def on_calcular_cables(self, event):  
        self.dict_ramas = {}
        self.path_min_a_cc = defaultdict(lambda: defaultdict(list))
        self.on_generar_arbol_actual(None)
        for _, centro_carga in self.on_buscar_centros_carga(None):
            for llave, clave in nx.single_source_dijkstra_path(self.network, centro_carga).items():
                self.path_min_a_cc[llave][centro_carga] = clave
                
    def compute_dist(self, rutas):
        dist = 0
        for i, ruta in enumerate(rutas[:-1]):
            dist += utilidades.Rama(ruta, rutas[i+1]).dist
        return dist

    def on_generar_arbol_actual(self, event):
        self.network = nx.Graph()
        self.dict_ramas = {}
        for obj in self.objetos:
            self.network.add_node(obj)
        for circuito, ramas in self.trayectorias.items():
            if not self.trayectorias_ver[circuito]:
                continue
            for rama in ramas:
                self.network.add_edge(rama.obj1, rama.obj2, weight=rama.dist)
                self.dict_ramas[(rama.obj1, rama.obj2)] = rama
                self.dict_ramas[(rama.obj2, rama.obj1)] = rama

    def on_ver(self, event):
        value  = not self.m_tool4.IsToggled()
        for key in self.trayectorias.keys():
            self.trayectorias_ver[key] = value
        wx.CallAfter(self.recalcular, None)

    def on_clean_trayectorias(self, event):
        for llave in self.trayectorias.keys():
            if llave == "personalizada":
                continue
            self.trayectorias[llave].clear()
        wx.CallAfter(self.recalcular, None)

    def on_propose_alimentacion(self, event):
        self.on_calcular_cables(None)
        H = self.create_node_network(None)
        for obj in self.objetos:
            aux = []
            #if obj.potencia <= 0:
            #    continue
            for llave, clave in self.path_min_a_cc[obj].items():
                aux.append((self.compute_dist(clave), clave))
            if len(aux)==0:
                continue
            ruta = min(aux)
            for i, nodo in enumerate(ruta[1][:-1]):
                rama = utilidades.Rama(nodo, ruta[1][i+1])
                H.add_edge(nodo, ruta[1][i+1], weight=rama.dist)
            obj.set_cc(ruta[1][0])
        for obj1, obj2 in H.edges():
            self.trayectorias["alimentaciones"].append(utilidades.Rama(obj1, obj2))
        wx.CallAfter(self.recalcular, None, False)

    def on_calcular_flujos(self, event):
        self.on_generar_arbol_actual(None)
        dict_ramas = {}
        self.trayectorias["flujos"].clear()
        self.trayectorias["fails_flujos"].clear()
        ramas = []
        for obj1, obj2 in self.network.edges():
            rama = utilidades.Rama(obj1, obj2)
            rama.dict_flujos = defaultdict(float)
            dict_ramas[(obj1, obj2)] = rama
            dict_ramas[(obj2, obj1)] = rama
            ramas.append(rama)
        for obj in self.objetos: 
            if obj.tipo in ["Centro de carga", "Lampara de techo", "Lampara de piso", "Lampara de pared"]:
                continue
            if obj.potencia <= 0:
                continue
            try:
                if obj.cc is None:
                    continue
            except:
                continue
            try:
                ruta = nx.shortest_path(self.network, obj, obj.cc, weight="weight")
            except:
                self.trayectorias["fails_flujos"].append(utilidades.Rama(obj, obj.cc))
                continue
            for i, obj1 in enumerate(ruta[:-1]):
                obj2 =  ruta[i+1]
                rama = dict_ramas[(obj1, obj2)]
                rama.dict_flujos[obj.circuito] += obj.potencia

        for rama in ramas:
            if len(rama.dict_flujos) != 0:
                self.trayectorias["flujos"].append(rama)

        wx.CallAfter(self.recalcular, None)
            
    def on_click_circuito(self, event):
        obj = event.GetEventObject()
        circuito = obj.GetCellValue(event.Row, 0)
        for obj in self.objetos:
            if obj.circuito == circuito:
                obj.__selected__ = True
            else:
                obj.__selected__ = False
        for ramas in self.trayectorias.values():
            for rama in ramas:
                rama.__selected__ = False

        for rama in self.trayectorias["flujos"]:
            if rama.dict_flujos[circuito] != 0:
                rama.__selected__ = True

        event.Skip()
        wx.CallAfter(self.m_panel2.Refresh)

    def on_calcular_cc_preferido(self, event):
        potencia_base = 100
        self.create_node_network(None)
        dict_distancias = defaultdict(lambda: defaultdict(lambda: 0)) 
        centros_carga = [x[1] for x in self.on_buscar_centros_carga(None)]
        self.trayectorias["fails_carga"].clear()
        for obj in self.objetos:
            if obj.tipo == "Centro de carga":
                continue
            if obj.potencia <= 0:
                continue
            for cc in centros_carga:
                try:
                    dist = nx.shortest_path_length(self.network, obj, cc, weight="weight")
                except:
                    self.trayectorias["fails_carga"].append(utilidades.Rama(obj, cc))
                    dist = 1000
                dict_distancias[obj.espacio][cc] += dist*(obj.potencia/potencia_base)
        
        datos = {data[0]: data for data in self.get_tabla_data(self.m_grid1)}
        for circuito, distancias in dict_distancias.items():
            min_distancia = min(distancias.items(), key=lambda x:x[1])
            datos[circuito][-1] = min_distancia[0].tag 

        aux = []
        for clave in datos.values():
            aux.append(clave)
        self.set_tabla_data(self.m_grid1, aux)

    def update_ramas(self, event):
        for ramas in self.trayectorias.values():
            for rama in ramas:
                rama.calcular_dist_obj()
                rama.calcular_punto_centro()

    def on_unselect(self, event):
        for obj in self.objetos:
            obj.__selected__ = False
        for ramas in self.trayectorias.values():
            for rama in ramas:
                rama.__selected__ = False

    def on_asignar_cc(self, event):
        self.dict_cc_x_circuito.clear()
        centros_carga = {x[1].tag: x[1] for x in self.on_buscar_centros_carga(None)}
        data = {x[0]: centros_carga.get(x[2], None) for x in self.get_tabla_data(self.m_grid2)}
        self.dict_cc_x_circuito.update(data)
        for obj in self.objetos:
            if obj.tipo == "Centro de carga":
                continue
            cc = data[obj.circuito]
            if cc is None:
                continue
            obj.set_cc(cc)

    def crear_dict_flujos(self, event):
        for ramas in self.trayectorias.values():
            for rama in ramas:
                rama.dict_flujos = defaultdict(float)


    def on_calcular_cableado(self, event):
        self.on_calcular_flujos(None)
        self.on_verificar_controles(None)
        if (len(self.trayectorias["fails"]) != 0 
                or len(self.trayectorias["fails_carga"]) != 0
                or len(self.trayectorias["fails_flujos"]) != 0):
            msg = "Error en la red: No se pudo conectar un control o un carga"
            dlg = wx.MessageDialog(None, msg, "", wx.OK|wx.ICON_INFORMATION)
            dlg.ShowModal()
            dlg.Destroy()
    
    def on_cc_force_change(self, event):     
        for circuito, carga, cc, i, awg, awg2 in self.get_tabla_data(self.m_grid2):
            self.dict_cc_x_circuito[circuito] = cc

    def on_cotizar_enmanguerado(self, event):
        self.on_generar_arbol_actual(None)
        num_trayectoria = len(self.network.edges)
        tipos = ["Lampara de techo", "Lampara de piso", "Lampara de pared"]
        num_registros = sum ([1 for x in self.objetos if x.tipo in tipos])
        print (f"Instalación de ducto,000284,Servicio,30,{num_trayectoria},{num_trayectoria*30},0,Casa VM")
        print (f"Instalación de caja de registro,000283,Servicio,10,{num_registros},{num_registros*10},0,Casa VM")

    def on_mouse_wheel(self, event):
        if not event.controlDown:
            return
        if  event.WheelRotation > 0:
            self.zoom += 0.05
        else:
            self.zoom -= 0.05
        #import pdb;pdb.set_trace()
        
        ancho, alto = self.m_scrolledWindow1.GetSize()
        self.m_panel2.SetSize(wx.Size(int(ancho*self.zoom), int(alto*self.zoom)))
        self.m_panel2.Refresh()


    def on_calcular_cuadro_carga_x_cc(self, event):

        self.dict_cargas.clear()
        keys = set()
        for obj in self.objetos:
            if obj.tipo == "Placa de accesorios":
                for hijo in obj.__hijos__:
                    if hijo.potencia <= 0:
                        continue
                    key = f"{hijo.tipo}-{hijo.potencia}W"
                    keys.add(key)
                    self.dict_cargas[obj.cc.tag][obj.circuito][key]["cantidad"] += 1
                    self.dict_cargas[obj.cc.tag][obj.circuito][key]["carga"] += hijo.potencia
            elif obj.tipo == "Centro de carga":
                continue
            else:
                key = f"{obj.tipo}-{obj.potencia}W"
                keys.add(key)
                self.dict_cargas[obj.cc.tag][obj.circuito][key]["cantidad"] += 1
                self.dict_cargas[obj.cc.tag][obj.circuito][key]["carga"] += obj.potencia
            
        self.panel_cuadro_carga = CuadroCarga(self, self.m_radioBox2.GetSelection(), keys)
        self.panel_cuadro_carga.Show()

    
    def on_caida_tension(self, event):
        data = {x[0]: [float(x[3]), int(x[4])] for x in self.get_tabla_data(self.m_grid2)}
        self.on_generar_arbol_actual(None)
        for obj in self.objetos:
            if obj.tipo == "Centro de carga":
                continue
            try:
                dist = nx.shortest_path_length(self.network, obj, obj.cc, weight="weight")
                if not isinstance(dist, float):
                    import pdb; pdb.set_trace()
            except:
                print (obj.tipo)
            e, awg = self.calcular_cable(dist, data[obj.circuito][0], 127, data[obj.circuito][1])
            obj.set_e(e)
            self.dict_awg_x_circuito[obj.circuito].add(awg)

    def calcular_cable(self, distancia, corriente, voltaje, awg_inicial):
        try:
            e = (4*distancia*corriente)/(voltaje*DICT_SECC_TRANS[awg_inicial])
        except:
            import pdb
            pdb.set_trace()
        if e < 3:
            return e, awg_inicial
        awg = self.incrementar_seccion(awg_inicial)
        return self.calcular_cable(distancia, corriente, voltaje, awg)
        
    def incrementar_seccion(self, awg):
        idx = CALIBRES.index(awg)
        return CALIBRES[idx + 1]










         

        
class PopMenu(wx.Menu):
    def __init__(self, parent, main_frame):
        super(PopMenu, self).__init__()
        self.parent = parent
        self.main_frame = main_frame
        popmenu = wx.MenuItem(self, wx.ID_ANY, 'Punto de origen')
        self.Append(popmenu)
        popmenu2 = wx.MenuItem(self, wx.ID_ANY, 'Configurar escala')
        self.Append(popmenu2)
        popmenu3 = wx.MenuItem(self, wx.ID_ANY, 'Agregar equipo')
        self.Append(popmenu3)
        popmenu5 = wx.MenuItem(self, wx.ID_ANY, 'Cancelar')
        self.Append(popmenu5)

        self.Bind(wx.EVT_MENU, self.cambiar_origen, popmenu)
        self.Bind(wx.EVT_MENU, self.configurar_escala, popmenu2)
        self.Bind(wx.EVT_MENU, self.agregar_elemento, popmenu3)
        if isinstance(self.main_frame.__data__, utilidades.Accesorio):
            popmenu4 = wx.MenuItem(self, wx.ID_ANY, 'Agregar rama')
            self.Append(popmenu4)
            self.Bind(wx.EVT_MENU, self.agregar_rama, popmenu4)
            popmenu6 = wx.MenuItem(self, wx.ID_ANY, 'Ruta a CC (mas proximo)')
            self.Append(popmenu6)
            self.Bind(wx.EVT_MENU, self.ruta_a_cc, popmenu6)
            popmenu7 = wx.MenuItem(self, wx.ID_ANY, 'Ruta a CC asignado')
            self.Append(popmenu7)
            self.Bind(wx.EVT_MENU, self.ruta_a_cc_2, popmenu7)
            if self.main_frame.__data__.tipo == "Placa de accesorios":
                popmenu8 = wx.MenuItem(self, wx.ID_ANY, 'Girar')
                self.Append(popmenu8)
                self.Bind(wx.EVT_MENU, self.on_girar_placa, popmenu8)
                popmenu9 = wx.MenuItem(self, wx.ID_ANY, 'Agregar Hijo')
                self.Append(popmenu9)
                self.Bind(wx.EVT_MENU, self.agregar_hijo, popmenu9)
        elif isinstance(self.main_frame.__data__, utilidades.Rama):
            popmenu10 = wx.MenuItem(self, wx.ID_ANY, 'Borrar rama')
            self.Append(popmenu10)
            self.Bind(wx.EVT_MENU, self.borrar_rama, popmenu10)
        self.Bind(wx.EVT_MENU, self.cancelar, popmenu5)
    
    def cambiar_origen(self, event):
        diff_x = self.main_frame.origen[0] - self.main_frame.x_abs
        diff_y = self.main_frame.origen[1] - self.main_frame.y_abs
        self.main_frame.origen = (self.main_frame.x_abs, self.main_frame.y_abs)
        for obj in self.main_frame.objetos:
            obj.x += diff_x*self.main_frame.escala
            obj.y += diff_y*self.main_frame.escala
            obj.actualizar_coordenadas_hijos()
        self.main_frame.update_ramas(None)
        self.main_frame.m_panel2.Refresh()
    
    def configurar_escala(self, event):
        self.main_frame.modo = CONF_ESCALA
        self.main_frame.referencia = (self.main_frame.x, self.main_frame.y)
    
    def agregar_elemento(self, event):
        self.main_frame.agregar_elemento = GestorElementos(
            self.main_frame, self.main_frame.x, self.main_frame.y
        )
        self.main_frame.agregar_elemento.Show()
    
    def agregar_rama(self, event):
        self.main_frame.modo = CREAR_RAMA
    
    def cancelar(self, event):
        self.main_frame.modo = NORMAL
    
    def ruta_a_cc(self, event):
        self.main_frame.on_calcular_cables(None)
        if not isinstance(self.main_frame.__data__, utilidades.Accesorio):
            return
        self.main_frame.on_unselect(None)
        aux = []
        for llave, clave in self.main_frame.path_min_a_cc[self.main_frame.__data__].items():
            aux.append((self.main_frame.compute_dist(clave), clave))
        if len(aux)==0:
            self.main_frame.m_statusBar1.SetStatusText("El nodo no se puede conectar a un centro de carga")
            return None
        ruta = min(aux)
        for i, obj in enumerate(ruta[1][:-1]):
            self.main_frame.dict_ramas[(obj, ruta[1][i+1])].__selected__ = True
            obj.__selected__ = True
        ruta[1][-1].__selected__ = True
        wx.CallAfter(self.main_frame.m_panel2.Refresh)

    def ruta_a_cc_2(self, event):
        if not isinstance(self.main_frame.__data__, utilidades.Accesorio):
            return
        if self.main_frame.__data__.cc is None:
            return
        self.main_frame.on_unselect(None)
        self.main_frame.on_generar_arbol_actual(None)
        try:
            ruta = nx.shortest_path(
                self.main_frame.network,
                self.main_frame.__data__, 
                self.main_frame.__data__.cc,
                weight="weight"
            )
        except:
            self.main_frame.m_statusBar1.SetStatusText("El nodo no se puede conectar a su centro de carga asignado")
            return None
        for i, obj in enumerate(ruta[:-1]):
            self.main_frame.dict_ramas[(obj, ruta[i+1])].__selected__ = True
            obj.__selected__ = True
        ruta[-1].__selected__ = True
        wx.CallAfter(self.main_frame.m_panel2.Refresh)
    
    def on_girar_placa(self, event):
        try:
            self.main_frame.__data__.girar = not self.main_frame.__data__.girar
        except:
            self.main_frame.__data__.girar = True
    
    def agregar_hijo(self, event):
        self.main_frame.agregar_elemento = GestorElementos(
            self.main_frame, self.main_frame.__data__.x, self.main_frame.__data__.y, self.main_frame.__data__.z, CREAR_HIJO, self.main_frame.__data__
        )
        self.main_frame.agregar_elemento.Show()

    def borrar_rama(self, event):
        flg = False
        for circuito, ramas in self.main_frame.trayectorias.items():
            for i, rama in enumerate(ramas):
                if rama == self.main_frame.__data__:
                    flg= True
                    break
            if flg:
                break    
        if not flg:
            return                
        self.main_frame.trayectorias[circuito].pop(i)
        wx.CallAfter(self.main_frame.recalcular, None)

            
    
class PopMenu2(wx.Menu):
    def __init__(self, parent, main_frame, data):
        super(PopMenu2, self).__init__()
        self.parent = parent
        self.main_frame = main_frame
        self.data = data
        popmenu = wx.MenuItem(self, wx.ID_ANY, 'Agregar Hijo')
        self.Append(popmenu)
        self.Bind(wx.EVT_MENU, self.agregar_elemento, popmenu)
        popmenu2 = wx.MenuItem(self, wx.ID_ANY, 'Borrar elemento')
        self.Append(popmenu2)
        self.Bind(wx.EVT_MENU, self.borrar_elemento, popmenu2)
    
    def agregar_elemento(self, event):
        self.main_frame.agregar_elemento = GestorElementos(
            self.main_frame, self.data.x, self.data.y, self.data.z, CREAR_HIJO, self.data
        )
        self.main_frame.agregar_elemento.Show()
    
    def borrar_elemento(self, event):
        try:
            idx = self.main_frame.objetos.index(self.data)
            self.main_frame.objetos.pop(idx)
        except:
            idx = self.main_frame.objetos.index(self.data.__padre__)
            self.main_frame.objetos[idx].eliminar_hijo(self.data)
        wx.CallAfter(self.main_frame.recalcular, None)


class PopMenu3(wx.Menu):
    def __init__(self, parent, main_frame, data, text=None):
        super(PopMenu3, self).__init__()
        self.parent = parent
        self.main_frame = main_frame
        self.data = data
        self.text = text
        popmenu = wx.MenuItem(self, wx.ID_ANY, 'Borrar rama')
        self.Append(popmenu)
        self.Bind(wx.EVT_MENU, self.borrar_rama, popmenu)
        try:
            if self.text in self.main_frame.trayectorias:
                if self.main_frame.trayectorias_ver[self.text]:
                    texto = "No ver"
                else:
                    texto = "Ver"
                popmenu2 = wx.MenuItem(self, wx.ID_ANY, texto)
                self.Append(popmenu2)
                self.Bind(
                    wx.EVT_MENU, 
                    (lambda evt, status= self.main_frame.trayectorias_ver[self.text]: 
                        self.ver_circuito(evt, status)),
                    popmenu2
                )
                popmenu3 = wx.MenuItem(self, wx.ID_ANY, "Copiar a personalizada")
                self.Append(popmenu3)
                self.Bind(wx.EVT_MENU, self.copiar_a_personalizado, popmenu3)
        except:
            pass
    
    def ver_circuito(self, event, status):
        self.main_frame.trayectorias_ver[self.text] = not status
        wx.CallAfter(self.main_frame.m_panel2.Refresh)
  
    
    def borrar_rama(self, event):
        flg = False
        for circuito, ramas in self.main_frame.trayectorias.items():
            for i, rama in enumerate(ramas):
                if rama == self.data[0]:
                    flg= True
                    break
            if flg:
                break    
        if not flg:
            return                
        self.main_frame.trayectorias[circuito].pop(i)
        wx.CallAfter(self.main_frame.m_panel2.Refresh)
        wx.CallAfter(self.main_frame.update_ramas_treectrl, None)

    def copiar_a_personalizado(self, event):
        self.main_frame.trayectorias["personalizada"] += self.main_frame.trayectorias[self.text]
        wx.CallAfter(self.main_frame.recalcular, None)

class CuadroDistancia(ejecutar_gestor.Distancia):
    def __init__( self, parent ):
        ejecutar_gestor.Distancia.__init__( self, parent )
        self.main_frame = parent

    def on_enter(self, event):
        dist = float(event.GetString())
        if self.main_frame.dist == 0:
            return
        old_escala = self.main_frame.escala
        self.main_frame.escala = dist/self.main_frame.dist
        escala_ratio = self.main_frame.escala/old_escala
        for obj in self.main_frame.objetos:
            obj.x *= escala_ratio
            obj.y *= escala_ratio
            obj.actualizar_coordenadas_hijos()
        self.main_frame.update_ramas(None)
        self.Close()

class GestorElementos(ejecutar_gestor.GestorElementos):
    def __init__( self, parent, x, y, z=None, modo=NORMAL, data=None):
        ejecutar_gestor.GestorElementos.__init__( self, parent)
        self.main_frame = parent
        self.x = x
        self.y = y
        self.z = z
        self.modo = modo
        self.data = data
        self.m_textCtrl_x.SetValue(f"{x:.2f}")
        self.m_textCtrl_y.SetValue(f"{y:.2f}")
        if self.z is not None:
            self.m_textCtrl_z.SetValue(f"{z:.2f}")
            self.m_textCtrl_espacio.SetValue(data.espacio)
            self.m_textCtrl_x.Enable(False)
            self.m_textCtrl_y.Enable(False)
            self.m_textCtrl_z.Enable(False)
            self.m_textCtrl_espacio.Enable(False)
        if self.modo == CREAR_HIJO:
            self.m_comboBox1.SetItems(
                ("Contacto sencillo",
                 "Contacto doble",
                 "Apagador 2 vias",
                 "Apagador 3 vias",
                 "Apagador 4 vias")
            )

    def on_choice(self, event):
        eleccion = event.GetString()
        idx = utilidades.TIPOS[eleccion]
        if self.z is None:
            self.z = utilidades.ALTURA_STD[idx]
        potencia = utilidades.POTENCIA_STD[idx]
        self.m_textCtrl_z.SetValue(f"{self.z:.2f}")
        self.m_textCtrl_potencia.SetValue(f"{potencia:.2f}")

    def on_ok(self, event):
        x = float(self.m_textCtrl_x.GetValue())
        y = float(self.m_textCtrl_y.GetValue())
        z = float(self.m_textCtrl_z.GetValue())
        potencia = float(self.m_textCtrl_potencia.GetValue())
        espacio = self.m_textCtrl_espacio.GetValue()
        tag = self.m_textCtrl_tag.GetValue()
        tipo = self.m_comboBox1.GetStringSelection()
        obj = utilidades.Accesorio(x, y, z, tipo, potencia, tag, espacio)
        if self.modo == CREAR_HIJO:
            obj.__padre__ = self.data
            self.data.append_hijo(obj)
            self.data.calc_pot()
        else:
            self.main_frame.objetos.append(obj)
        wx.CallAfter(self.main_frame.recalcular, None)
        self.Close()

class CuadroCarga(ejecutar_gestor.CuadroCarga):
    def __init__( self, parent, modo, llaves):
        ejecutar_gestor.CuadroCarga.__init__( self, parent)
        self.main_frame = parent
        self.modo = modo
        self.llaves = llaves 

        ccs = list(self.main_frame.dict_cargas.keys())
        self.m_comboBox2.SetItems(ccs)
        fases = ["A", "B", "C"]
        encabezados = fases[:modo+1] + ["circuito"] + list(llaves) + ["total W"] + fases[:modo+1] + ["corriente"] + ["calibre cable"]
        self.main_frame.clean_table_cols(self.m_grid3)
        self.main_frame.clean_table_cols(self.m_grid5)
        self.m_grid3.InsertCols(pos=0, numCols=len(encabezados), updateLabels=True)
        self.m_grid5.InsertCols(pos=0, numCols=modo + 1, updateLabels=True)

        for i, encabezado in enumerate(encabezados):
            self.m_grid3.SetColLabelValue(i, encabezado)

        for i, encabezado in enumerate(fases[:modo+1]):
            self.m_grid5.SetColLabelValue(i, encabezado)

        self.checkbox_columnas = range(self.modo + 1)
        for col in self.checkbox_columnas:
            attr = wx.grid.GridCellAttr()
            attr.SetEditor(wx.grid.GridCellBoolEditor())
            attr.SetRenderer(wx.grid.GridCellBoolRenderer())
            self.m_grid3.SetColAttr(col,attr)

    def on_combo_box(self, event):
        cc = event.GetString()
        data = []
        for circuito, cargas in self.main_frame.dict_cargas[cc].items():
            aux = []
            for _ in range(self.modo + 1):
                aux.append("")
            aux.append(circuito)
            total = 0
            for llave in self.llaves:
                aux.append(cargas[llave]["cantidad"])
                total += cargas[llave]["carga"]
            aux.append(total)
            for _ in range(self.modo + 1):
                aux.append("")
            corriente = total/127
            aux.append(corriente)
            aux.append("")
            data.append(aux)
        self.main_frame.set_tabla_data(self.m_grid3, data)
                



def main():
    app = wx.App()
    ex = gestor_planos_electricos_MainFrame(None)
    ex.Show()
    app.MainLoop()

if __name__ == '__main__':
    main()