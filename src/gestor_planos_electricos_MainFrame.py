"""Subclass of MainFrame, which is generated by wxFormBuilder."""

import wx
import ejecutar_gestor
import utilidades
import pickle
import networkx as nx
from collections import defaultdict

NORMAL = 0
CONF_ESCALA = 1
CREAR_HIJO = 1
FACTOR_MARGEN_X_CURVAS = 1.2
DIST_MIN = 0.1

# Implementing MainFrame
class gestor_planos_electricos_MainFrame( ejecutar_gestor.MainFrame ):
    def __init__( self, parent ):
        ejecutar_gestor.MainFrame.__init__( self, parent )
        self.img = None
        self.ancho = 0
        self.alto = 0
        self.escala = 1
        self.escala_x = 0
        self.escala_y = 0
        self.origen = (0, 0)
        self.centro_carga = None
        self.x = 0
        self.y = 0
        self.x_abs = 0
        self.y_abs = 0
        self.referencia = (0, 0)
        self.modo = 0
        self.cuadro_distancia = None
        self.agregar_elemento = None
        self.trayectorias = None
        self.alimentadores = None
        self.dist = None
        self.objetos = []
        self.dict_tree = {}
        self.__data__ = None
        self.update_treectrl(None)
        self.tags = defaultdict(lambda:{"controles":[], "lamparas": []})
        self.m_dataViewListCtrl.AppendTextColumn("Atributo", width=150)
        self.m_dataViewListCtrl.AppendTextColumn(
            "Valor", width=80, mode=wx.dataview.DATAVIEW_CELL_EDITABLE
        )

        self.imgs = {
            1: wx.Image("img/Centro_de_carga.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            3: wx.Image("img/Contacto_sencillo.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            4: wx.Image("img/Contacto_doble.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            5: wx.Image("img/Apagador_2_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            6: wx.Image("img/Apagador_3_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            7: wx.Image("img/Apagador_4_vias.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            8: wx.Image("img/Lampara_de_techo.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            9: wx.Image("img/Lampara_de_pared.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            10: wx.Image("img/Lampara_de_piso.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            11: wx.Image("img/Placa_accesorios1.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            12: wx.Image("img/Placa_accesorios2.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
            13: wx.Image("img/Placa_accesorios3.png", wx.BITMAP_TYPE_ANY).ConvertToBitmap(),
        }

    def on_file_change(self, event):
        obj = event.EventObject
        self.path = obj.GetPath()
        self.img = wx.Image(self.path, wx.BITMAP_TYPE_ANY)
        self.ancho, self.alto = self.img.GetSize()
        #self.pil_img = Image.open(self.path)
        self.m_panel2.Refresh()
        #self.m_filePicker.Enable(True)
    
    def on_paint(self, event):
        """Metodo para dibujar sobre un panel"""
        if self.img is not None:
            self.pintar(event.EventObject, self.img)
        event.Skip()
    
    def pintar(self, panel, img):
        """Redibuja una imagen sobre un panel"""

        dc = wx.PaintDC(panel)
        dc.Clear()
        dc.SetBackground(wx.Brush("WHITE"))
        ancho, alto = panel.GetSize()
        self.escala_x = ancho/self.ancho
        self.escala_y = alto/self.alto
        if 0 in (ancho, alto):
            return 
        if self.img:
            imagenEscalada = self.img.Scale(
                ancho, alto, wx.IMAGE_QUALITY_HIGH
            )
            bitmap = imagenEscalada.ConvertToBitmap()
            dc.DrawBitmap(bitmap, 0, 0, True)
            x, y = self.convert_2_pixels(
                (self.x_abs, self.y_abs)
            )
            dc.SetBrush(wx.Brush("#FF0000"))
            dc.DrawCircle(
                int(self.origen[0]*self.escala_x), 
                int(int(self.origen[1]*self.escala_y)), 5)
            if self.centro_carga is not None:
                x, y = self.convert_2_pixels(
                    (self.centro_carga[0]/self.escala,
                    self.centro_carga[1]/self.escala)
                )
                dc.SetBrush(wx.Brush("#FF00FF"))
                dc.DrawCircle(
                    int(x), int(y), 5
                )
            for obj in self.objetos:
                x, y =self.convert_2_pixels((obj.x/self.escala, obj.y/self.escala))
                if obj.tipo in ["Lampara de piso", "Lampara de techo", "Lampara de pared", "Centro de carga"]:
                    idx = utilidades.TIPOS[obj.tipo]
                    ancho, alto = self.imgs[idx].GetSize()
                    dc.DrawBitmap(self.imgs[idx], int(x - ancho*0.5), int(y - alto*0.5), True)
                elif obj.tipo == "Placa de accesorios":
                    if len(obj.__hijos__)!= 0:
                        idx = 10 + len(obj.__hijos__)
                    else:
                        idx = 11
                    ancho_placa, alto_placa = self.imgs[idx].GetSize()
                    dc.DrawBitmap(self.imgs[idx], int(x - ancho_placa*0.5), int(y - alto_placa*0.5), True)
                    if len(obj.__hijos__) > 0:
                        step_ancho = ancho_placa/(len(obj.__hijos__)) 
                        for i, hijo in enumerate(obj.__hijos__):
                            idx = utilidades.TIPOS[hijo.tipo]
                            ancho, alto = self.imgs[idx].GetSize()
                            dc.DrawBitmap(self.imgs[idx], int(x - ancho_placa*0.5 + step_ancho*i), int(y - alto_placa*0.5), True)
                if obj.__selected__:
                    dc.SetBrush(wx.Brush("#FF0000"))   
                    dc.DrawCircle(int(x), int(y), 5)
        
        
        if self.trayectorias is not None:
            for rama in self.trayectorias:
                if rama.__selected__:
                    dc.SetPen(wx.Pen("#FF0000"))
                else:
                    dc.SetPen(wx.Pen(rama.color))
                x1, y1 = self.convert_2_pixels((rama.obj1.x/self.escala, rama.obj1.y/self.escala))
                x2, y2 = self.convert_2_pixels((rama.obj2.x/self.escala, rama.obj2.y/self.escala))
                xm, ym = self.convert_2_pixels((rama.punto_centro[0]/self.escala, rama.punto_centro[1]/self.escala))
                dc.DrawLine(int(x1), int(y1), int(x2), int(y2))
                dc.DrawText(f"{rama.dist:.2f}", int(xm), int(ym))

        if self.modo == CONF_ESCALA:
            x_ref, y_ref = self.convert_2_pixels(
                (self.referencia[0], self.referencia[1])
            )
            x, y = self.convert_2_pixels(
                (self.x, self.y)
            )
            dc.DrawLine(int(x_ref), int(y_ref), int(x), int(y))
            

    def convert_2_pixels(self, punto):
        """Convierte puntos en la imagen en coordenadas para el panel"""
        x, y = punto
        x = (x + self.origen[0]) * self.escala_x
        y = (y + self.origen[1]) * self.escala_y
        return x, y

    def on_change_size(self, event):
        self.Layout()
        self.Update()
        self.m_panel2.Refresh()

    def on_sash_changed(self, event):
        self.on_change_size(None)
    
    def on_mouse_motion(self, event):
        """Captura los movimientos del raton dentro del panel de dibujo"""
        if 0 in (self.escala_x, self.escala_y):
            return 
        self.x_abs = event.x/self.escala_x
        self.y_abs = event.y/self.escala_y
        self.x = (event.x/self.escala_x - self.origen[0])*self.escala
        self.y = (event.y/self.escala_y - self.origen[1])*self.escala
        
        self.m_statusBar1.SetStatusText(
            f"X: {self.x:.2f}  Y: {self.y:.2f}"
        )
        if self.modo == CONF_ESCALA:
            self.m_panel2.Refresh()

    def on_context_menu(self, event):
        self.PopupMenu(PopMenu(self.m_panel2, self))

    def on_left_down(self, event):
        if self.modo == CONF_ESCALA:
            self.modo = NORMAL
            self.m_panel2.Refresh()
            self.dist = self.calc_dist((self.x, self.y), (self.referencia))
            if self.cuadro_distancia is None:
                self.cuadro_distancia = CuadroDistancia(self)
                self.cuadro_distancia.Show()
        elif self.modo == NORMAL:
            for i, obj in enumerate(self.objetos):
                dist = self.calc_dist((self.x, self.y), (obj.x, obj.y))
                if dist < DIST_MIN:
                    self.update_data_ctrl(obj, self.m_dataViewListCtrl)
                    obj.__selected__ = True
                    self.__data__ = obj
                    wx.CallAfter(self.m_panel2.Refresh)
                    item = self.dict_tree.get(i, None)
                    if item is not None:
                        wx.CallAfter(self.m_treeCtrl.EnsureVisible, item)
                        wx.CallAfter(self.SetItemBackgroundColour, item, self.dict_tree, self.m_treeCtrl)
                else:
                    obj.__selected__ = False

            for i, obj in enumerate(self.trayectorias):
                dist = self.calc_dist((self.x, self.y), (obj.punto_centro[0], obj.punto_centro[1]))
                if dist < DIST_MIN*3:
                    self.update_data_ctrl(obj, self.m_dataViewListCtrl)
                    obj.__selected__ = True
                    self.__data__ = obj
                    wx.CallAfter(self.m_panel2.Refresh)
                    item = self.dict_ramas_tree.get(i, None)
                    if item is not None:
                        wx.CallAfter(self.m_treeCtrl_ramas.EnsureVisible, item)
                        wx.CallAfter(self.SetItemBackgroundColour, item, self.dict_ramas_tree, self.m_treeCtrl_ramas)
                else:
                    obj.__selected__ = False

    def SetItemBackgroundColour(self, item, tree_ctrl_dict, tree_ctrl):
        for valor in tree_ctrl_dict.values():
            tree_ctrl.SetItemBackgroundColour(valor, wx.Colour("#FFFFFF"))
        wx.CallAfter(tree_ctrl.SetItemBackgroundColour,item, wx.Colour("#FF4258"))
        
    def calc_dist(self, p1, p2):
        "Calcula la distancia entre 2 puntos"
        if isinstance(p1, utilidades.Accesorio) and isinstance(p2, utilidades.Accesorio):
            return ((p2.x-p1.x)**2 + (p2.y-p1.y)**2)**0.5
        else:
            return ((p2[0]-p1[0])**2 + (p2[1]-p1[1])**2)**0.5
    
    def update_treectrl(self, event):
        self.dict_tree = {}
        self.m_treeCtrl.DeleteAllItems()
        self.root = self.m_treeCtrl.AddRoot('Accesorios')
        for i, obj in enumerate(self.objetos):
            aux = self.m_treeCtrl.AppendItem(self.root,f"{i}-{obj.tipo}", data=obj)
            self.dict_tree[i] = aux
            for j, hijo in enumerate(obj.__hijos__):
                self.m_treeCtrl.AppendItem(aux,f"{j}-{hijo.tipo}", data=hijo)
        self.m_treeCtrl.Expand(self.root)
    
    def update_tag_treectrl(self, event):
        self.dict_tag_tree = {}
        self.m_treeCtrl_tags.DeleteAllItems()
        self.root_tags = self.m_treeCtrl_tags.AddRoot('Tags')
        for i, (tag, valores) in enumerate(self.tags.items()):
            tags_root = self.m_treeCtrl_tags.AppendItem(self.root_tags, tag, data=valores["lamparas"]+valores["controles"])
            controles_root = self.m_treeCtrl_tags.AppendItem(tags_root, "controles", data=valores["controles"])
            lamparas_root = self.m_treeCtrl_tags.AppendItem(tags_root, "lamparas", data=valores["lamparas"])
            for control in valores["controles"]:
                self.m_treeCtrl_tags.AppendItem(controles_root, f"{control.tipo}", data=[control])
            for lampara in valores["lamparas"]:
                self.m_treeCtrl_tags.AppendItem(lamparas_root, f"{lampara.tipo}", data=[lampara])
        self.m_treeCtrl_tags.Expand(self.root_tags)

    def update_ramas_treectrl(self, event):
        self.dict_ramas_tree = {}
        self.m_treeCtrl_ramas.DeleteAllItems()
        self.root_ramas = self.m_treeCtrl_ramas.AddRoot('Ramas')
        for i, rama in enumerate(self.trayectorias):
            ramas_root = self.m_treeCtrl_ramas.AppendItem(self.root_ramas, str(i), data=rama)
            self.dict_ramas_tree[i] = ramas_root
            self.m_treeCtrl_ramas.AppendItem(ramas_root, f"{rama.obj1.tipo}", data=rama.obj1)
            self.m_treeCtrl_ramas.AppendItem(ramas_root, f"{rama.obj2.tipo}", data=rama.obj2)
        self.m_treeCtrl_ramas.Expand(self.root_ramas)

    def on_click(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        self.update_data_ctrl(data, self.m_dataViewListCtrl)
        for obj in self.objetos:
            obj.__selected__ = False
        data.__selected__ = True
        self.__data__ = data
        wx.CallAfter(self.m_panel2.Refresh)
    
    def on_click_tags(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        if len(data) == 1:
            self.update_data_ctrl(data[0], self.m_dataViewListCtrl)
            self.__data__ = data[0]
        for obj in self.objetos:
            obj.__selected__ = False
        for obj in data:
            obj.__selected__ = True
            if obj.__padre__ is not None:
                obj.__padre__.__selected__ = True 
        wx.CallAfter(self.m_panel2.Refresh)

    def on_click_ramas(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        self.update_data_ctrl(data, self.m_dataViewListCtrl)
        self.__data__ = data
        for obj in self.objetos:
            obj.__selected__ = False
        for obj in self.trayectorias:
            obj.__selected__ = False
        data.__selected__ = True   
        if isinstance(data, utilidades.Rama):
            data.obj1.__selected__ = True        
            data.obj2.__selected__ = True        
        wx.CallAfter(self.m_panel2.Refresh)

    def update_data_ctrl(self, data, obj):
        """Muestra en pantalla los datos de un objeto del tipo NewData.
        Los atributos que inican y terminan con 2 guiones bajos no son desplegados
        
        Parameters
        ----------
        data: NewData obj
            Objeto cuya información se desea desplegar ne pantalla
        obj: wx.DataViewCtrl
            Objeto donde se desea monstrar la información.
        """
        if data is None:
            return None
        obj.DeleteAllItems()
        encabezados = list(data.__dict__.keys())
        for encabezado in encabezados:
            if encabezado.startswith("__") and encabezado.endswith("__"):
                continue
            obj.AppendItem([encabezado,str(getattr(data,encabezado))])  

    def on_context_menu_treectrl(self, event):
        itemID = event.GetItem()
        tree_ctrl = event.EventObject
        data = tree_ctrl.GetItemData(itemID)
        self.PopupMenu(PopMenu2(self.m_treeCtrl, self, data))

    def on_save(self, event):
        data = {
           #"img" : {
           #     'pixels': self.img.GetData(),
           #     'size': self.img.GetSize(),
           # },
           "objetos" : self.objetos,
           "origen" : self.origen,
           "escala" : self.escala,
           "escala_x": self.escala_x,
           "escala_y": self.escala_y,
           "x_abs": self.x_abs,
           "y_abs": self.y_abs,
           "path": self.path,
           "circuitos_data": self.get_tabla_data(self.m_grid1),
        }
        dlg = wx.FileDialog(self, "Archivo de recuperacion",wildcard="*.pkl", style=wx.FD_SAVE)
        if dlg.ShowModal() == wx.ID_CANCEL:
            return
        # save the current contents in the file
        pathname = dlg.GetPath()
        dbfile = open(pathname, 'wb')     
        pickle.dump(data, dbfile)                    
        dbfile.close()
    
    def on_open(self, event):
        dlg = wx.FileDialog(self, "Archivo de recuperacion","", "","*.pkl", style=wx.FD_OPEN)
        if dlg.ShowModal() == wx.ID_CANCEL:
            return
        # save the current contents in the file
        pathname = dlg.GetPath()
        dict_file = open(pathname, 'rb')  
        dict_pkld = pickle.load(dict_file)
        dict_file.close()
        self.objetos = dict_pkld["objetos"]
        self.origen = dict_pkld["origen"]
        self.escala = dict_pkld["escala"]
        self.escala_x = dict_pkld["escala_x"]
        self.escala_y = dict_pkld["escala_y"]
        self.x_abs = dict_pkld["x_abs"]
        self.y_abs = dict_pkld["y_abs"]
        self.path = dict_pkld["path"]
        self.set_tabla_data(self.m_grid1, dict_pkld["circuitos_data"])
        self.img = wx.Image(self.path, wx.BITMAP_TYPE_ANY)
        self.ancho, self.alto = self.img.GetSize()
        wx.CallAfter(self.m_panel2.Refresh)
        wx.CallAfter(self.update_treectrl, None)

    def on_calc_carga(self, event):
        carga = 0
        for obj in self.objetos:
            carga += obj.potencia
        self.m_textCtrl_carga.SetValue(f"{carga:.2f}")
        return carga

    def on_calc_centro_carga(self, event):
        
        carga = self.on_calc_carga(None)
        carga_x_ponderada = 0
        carga_y_ponderada = 0
        for obj in self.objetos:
            carga_x_ponderada += obj.x*obj.potencia
            carga_y_ponderada += obj.y*obj.potencia
        self.centro_carga = (
            carga_x_ponderada/carga, carga_y_ponderada/carga
        )
        wx.CallAfter(self.m_panel2.Refresh)

    def on_calc_distancias_minimas(self, event):
        self.trayectorias = self.calcula_trayectorias_minimas()
        distancia = 0
        for rama in self.trayectorias:
            distancia += rama.dist
        self.m_textCtrl_distancia.SetValue(f"{distancia:.2f}")
        wx.CallAfter(self.update_ramas_treectrl, None)
        wx.CallAfter(self.m_panel2.Refresh)

    def calcular_dist_obj(self, obj1, obj2):
        """Calcula la distancia entre dos objetos"""
        if obj1.tipo == "Placa de accesorios" and obj1.tipo==obj2.tipo:
            delta_z = abs(obj1.z + obj2.z)
        else:
            delta_z = abs(obj1.z - obj2.z)
        dist = self.calc_dist((obj1.x, obj1.y), (obj2.x, obj2.y))
        return (delta_z + dist) * FACTOR_MARGEN_X_CURVAS
    
    def calcula_trayectorias_minimas(self):
        """Calcula mediante teoria de grafos las uniones minimas para conectar todos los
        puntos de la red domestica"""
        flg = self.m_checkBox2.GetValue()
        flg_2 = self.m_checkBox1.GetValue()
        flg_3 = self.m_checkBox3.GetValue()
        flg_4 = self.m_checkBox4.GetValue()
        if flg:
            dict_circuitos = {data[0]: data[1] for data in self.get_tabla_data(self.m_grid1)}
        G = nx.Graph()
        for i, obj1 in enumerate(self.objetos):
            G.add_node(i)
        for i, obj1 in enumerate(self.objetos):
            for j, obj2 in enumerate(self.objetos[:i]):
                if flg_2:
                    if obj1.tipo == "Placa de accesorios" and obj1.tipo==obj2.tipo:
                        continue
                if flg:
                    if dict_circuitos[obj1.espacio] != dict_circuitos[obj2.espacio]:
                        continue
                dist = self.calcular_dist_obj(obj1, obj2)
                G.add_edge(i, j, weight=dist)

        if flg_3:
            alimentadores = self.on_calcular_alimentadores(None)
            for i, j, _ in alimentadores:
                G.add_edge(i, j, weight=0.01)
        if flg_4:
            controles = self.on_calcular_controles(None)
            for i, j, _ in controles:
                G.add_edge(i, j, weight=0.01)
        T = nx.minimum_spanning_tree(G)
        return [utilidades.Rama(self.objetos[i], self.objetos[j])  for i, j, _ in  sorted(T.edges(data=True))]
    
    def on_calcular_controles(self, event):
        self.on_buscar_tags(None)
        controles = []
        for tag, data in self.tags.items():
            G = nx.Graph()
            for lampara in data["lamparas"]: 
                idx = self.objetos.index(lampara)
                G.add_node(idx)
            for control in data["controles"]: 
                idx = self.objetos.index(control.__padre__)
                G.add_node(idx)
            for i, obj1 in enumerate(data["lamparas"]):
                idx1 = self.objetos.index(obj1)
                for _, obj2 in enumerate(data["lamparas"][:i]):
                    dist = self.calcular_dist_obj(obj1, obj2)
                    idx2 = self.objetos.index(obj2)
                    G.add_edge(idx1, idx2, weight=dist)
                for control in data["controles"]:
                    dist = self.calcular_dist_obj(control, obj1)
                    idx2 = self.objetos.index(control.__padre__)
                    G.add_edge(idx1, idx2, weight=dist)
            T = nx.minimum_spanning_tree(G)
            controles += sorted(T.edges(data=True))   
        return controles   
       
    def encontrar_foco_mas_cercano(self, placa):
        aux = []
        for i, obj in enumerate(self.objetos):
            if obj.tipo not in ["Lampara de techo", "Lampara de piso", "Lampara de pared"]:
                continue
            dist = self.calcular_dist_obj(placa, obj)
            aux.append((dist, i))
        return (min(aux))

    def on_edit_data( self, event):
        """Permite la edición de un accesorio.
        """
        data_view_column = event.GetDataViewColumn()
        data_view_list_ctrl = data_view_column.GetOwner()
        item = event.GetItem()
        row = data_view_list_ctrl.ItemToRow(item)
        column = event.Column
        new_value = event.Value
        field = data_view_list_ctrl.GetValue(row,0)
        if column == 0:
            return None
        tipo = type(getattr(self.__data__, field))
        setattr(self.__data__,field,tipo(new_value))

        wx.CallAfter(self.m_panel2.Refresh)
        wx.CallAfter(self.update_treectrl, None)
        self.m_statusBar1.SetStatusText("Articulo modificado exitosamente")
        event.Skip()
    
    def on_buscar_tags(self, event):
        self.tags.clear()
        for obj in self.objetos:
            for hijo in obj.__hijos__:
                if hijo.tag == "":
                    continue
                self.tags[hijo.tag]["controles"].append(hijo) 
            if obj.tag == "":
                continue
            self.tags[obj.tag]["lamparas"].append(obj)
        self.update_tag_treectrl(None)
    
    def on_buscar_espacios(self, event):
        espacios = {obj.espacio for obj in self.objetos}
        data = [[espacio, ""] for espacio in espacios]
        self.set_tabla_data(self.m_grid1, data)

    def clean_table_data(self, grid):
        """Borra la informacion de una tabla"""
        num_rows = grid.GetNumberRows()
        if num_rows != 0:
            grid.DeleteRows(numRows=num_rows)

    def set_tabla_data(self, grid, data):
        """Borra la informacion de una tabla y la rellena con los valores en data"""
        self.clean_table_data(grid)
        grid.InsertRows(numRows=len(data))
        for i, row in enumerate(data):
            for j, cell_value in enumerate(row):
                if isinstance(cell_value, dict):
                    choice_editor = wx.grid.GridCellChoiceEditor(cell_value["data"], True)
                    grid.SetCellValue(i,j,str(cell_value["eleccion"]))
                    grid.SetCellEditor(i, j, choice_editor)
                else:
                    grid.SetCellValue(i,j,str(cell_value))
        grid.Refresh()
    
    def get_tabla_data(self, grid):
        """Obtiene la información de la tabla y la eentrega como una lista de listas"""
        num_rows = grid.GetNumberRows()
        num_cols = grid.GetNumberCols()
        data = []
        for row in range(num_rows):
            aux = []
            for col in range(num_cols):
                aux.append(grid.GetCellValue(row, col))
            data.append(aux)
        return data
    
    def on_calcular_alimentadores(self, event):
        """Secciona los objetos por circuitos y despues calcula la distancia minima de
        uno de los accesorios del circuito al centro de carga"""
        dict_circuitos = {data[0]: data[1] for data in self.get_tabla_data(self.m_grid1)}
        dict_objetos = defaultdict(list)
        for i,obj in enumerate(self.objetos):
            if obj.espacio == "":
                continue
            dict_objetos[dict_circuitos[obj.espacio]].append((i, obj))
        centros_carga = self.on_buscar_centros_carga(None)

        resultados = defaultdict(list)
        for circuito, objetos in dict_objetos.items():
            for idx, centro_carga in centros_carga: 
                aux = []           
                for idy, obj in objetos:
                    if obj.tipo == "Placa de accesorios":
                        continue
                    dist = self.calcular_dist_obj(centro_carga, obj)
                    aux.append((idx, idy, dist))
                resultados[circuito].append(min(aux, key= lambda x:x[-1]))
        alimentadores = []
        for clave in resultados.values():
            alimentador = min(clave, key= lambda x:x[-1])
            alimentadores.append((alimentador[0], alimentador[1], {"weight": alimentador[2]}))
        return alimentadores


    def on_buscar_centros_carga(self, event):
        centros_carga = []
        for i, obj in enumerate(self.objetos):
            if obj.espacio == "":
                continue
            if obj.tipo != "Centro de carga":
                continue
            centros_carga.append((i, obj))
        return centros_carga

        

        
class PopMenu(wx.Menu):
    def __init__(self, parent, main_frame):
        super(PopMenu, self).__init__()
        self.parent = parent
        self.main_frame = main_frame
        popmenu = wx.MenuItem(self, wx.ID_ANY, 'Punto de origen')
        self.Append(popmenu)
        popmenu2 = wx.MenuItem(self, wx.ID_ANY, 'Configurar escala')
        self.Append(popmenu2)
        popmenu3 = wx.MenuItem(self, wx.ID_ANY, 'Agregar equipo')
        self.Append(popmenu3)

        self.Bind(wx.EVT_MENU, self.cambiar_origen, popmenu)
        self.Bind(wx.EVT_MENU, self.configurar_escala, popmenu2)
        self.Bind(wx.EVT_MENU, self.agregar_elemento, popmenu3)
    
    def cambiar_origen(self, event):
        diff_x = self.main_frame.origen[0] - self.main_frame.x_abs
        diff_y = self.main_frame.origen[1] - self.main_frame.y_abs
        self.main_frame.origen = (self.main_frame.x_abs, self.main_frame.y_abs)
        for obj in self.main_frame.objetos:
            obj.x += diff_x
            obj.y += diff_y
        self.main_frame.m_panel2.Refresh()
    
    def configurar_escala(self, event):
        self.main_frame.modo = CONF_ESCALA
        self.main_frame.referencia = (self.main_frame.x, self.main_frame.y)
    
    def agregar_elemento(self, event):
        self.main_frame.agregar_elemento = GestorElementos(
            self.main_frame, self.main_frame.x, self.main_frame.y
        )
        self.main_frame.agregar_elemento.Show()

class PopMenu2(wx.Menu):
    def __init__(self, parent, main_frame, data):
        super(PopMenu2, self).__init__()
        self.parent = parent
        self.main_frame = main_frame
        self.data = data
        popmenu = wx.MenuItem(self, wx.ID_ANY, 'Agregar Hijo')
        self.Append(popmenu)
        self.Bind(wx.EVT_MENU, self.agregar_elemento, popmenu)
    
    def agregar_elemento(self, event):
        self.main_frame.agregar_elemento = GestorElementos(
            self.main_frame, self.data.x, self.data.y, self.data.z, CREAR_HIJO, self.data
        )
        self.main_frame.agregar_elemento.Show()


class CuadroDistancia(ejecutar_gestor.Distancia):
    def __init__( self, parent ):
        ejecutar_gestor.Distancia.__init__( self, parent )
        self.main_frame = parent

    def on_enter(self, event):
        dist = float(event.GetString())
        if self.main_frame.dist == 0:
            return
        old_escala = self.main_frame.escala
        self.main_frame.escala = dist/self.main_frame.dist
        escala_ratio = self.main_frame.escala/old_escala
        for obj in self.main_frame.objetos:
            obj.x *= escala_ratio
            obj.y *= escala_ratio
        self.Close()

class GestorElementos(ejecutar_gestor.GestorElementos):
    def __init__( self, parent, x, y, z=None, modo=NORMAL, data=None):
        ejecutar_gestor.GestorElementos.__init__( self, parent)
        self.main_frame = parent
        self.x = x
        self.y = y
        self.z = z
        self.modo = modo
        self.data = data
        self.m_textCtrl_x.SetValue(f"{x:.2f}")
        self.m_textCtrl_y.SetValue(f"{y:.2f}")
        if self.z is not None:
            self.m_textCtrl_z.SetValue(f"{z:.2f}")
            self.m_textCtrl_espacio.SetValue(data.espacio)
            self.m_textCtrl_x.Enable(False)
            self.m_textCtrl_y.Enable(False)
            self.m_textCtrl_z.Enable(False)
            self.m_textCtrl_espacio.Enable(False)
        if self.modo == CREAR_HIJO:
            self.m_comboBox1.SetItems(
                ("Contacto sencillo",
                 "Contacto doble",
                 "Apagador 2 vias",
                 "Apagador 3 vias",
                 "Apagador 4 vias")
            )

    def on_choice(self, event):
        eleccion = event.GetString()
        idx = utilidades.TIPOS[eleccion]
        if self.z is None:
            self.z = utilidades.ALTURA_STD[idx]
        potencia = utilidades.POTENCIA_STD[idx]
        self.m_textCtrl_z.SetValue(f"{self.z:.2f}")
        self.m_textCtrl_potencia.SetValue(f"{potencia:.2f}")

    def on_ok(self, event):
        x = float(self.m_textCtrl_x.GetValue())
        y = float(self.m_textCtrl_y.GetValue())
        z = float(self.m_textCtrl_z.GetValue())
        potencia = float(self.m_textCtrl_potencia.GetValue())
        espacio = self.m_textCtrl_espacio.GetValue()
        tag = self.m_textCtrl_tag.GetValue()
        tipo = self.m_comboBox1.GetStringSelection()
        obj = utilidades.Accesorio(x, y, z, tipo, potencia, tag, espacio)
        if self.modo == CREAR_HIJO:
            obj.__padre__ = self.data
            self.data.append_hijo(obj)
            self.data.calc_pot()
        else:
            self.main_frame.objetos.append(obj)
        wx.CallAfter(self.main_frame.m_panel2.Refresh)
        wx.CallAfter(self.main_frame.update_treectrl, None)
        wx.CallAfter(self.main_frame.on_buscar_tags, None)
        wx.CallAfter(self.main_frame.on_buscar_espacios, None)
        self.Close()

def main():
    app = wx.App()
    ex = gestor_planos_electricos_MainFrame(None)
    ex.Show()
    app.MainLoop()

if __name__ == '__main__':
    main()